# 生成器疑问之为什么第一次 next 传参无效？

生成器函数的特点：每次调用一次 next() 都会执行一次 yield，并暂停生成器函数内部的执行。

看似浪费了一次传参机会，但是却保证了每调用一次 next()，都会执行一次 yield 的语义一致性。

可以看作是一个需要先 `预热` 再 `接收输入` 的设备或者过程

## 类比生活中的场景

### 场景一:用户命令行创建项目

比如 vite

第一次没有用户自定义内容

后面可以用户自定义

## 场景二：流水线上生产显示器

流水线上生产显示器，第一个工人搬基础，没人给他传零件做铺垫，它可以给其他工人传递零件

一个自动化流水线上有几个关键的工人 next()

第一个工人把物品搬到流水线上（没空加其他的料）：next() ，经过一些自动化机械操作，产品生产第一次阶段完成 yield

下一个工人往流水线上添加螺丝： next (螺丝)，流水线上就有了螺丝，一顿自动化机械操作，产品这个阶段生产任务完成 yield

下一个工人往流水线上加导线： next (导线)，流水线上就有了导线，一顿自动化机械操作，产品这个阶段生产任务完成 yield

...

拓展思考：
生成器函数的主要特点是：**可中断执行、惰性求值、多阶段返回值。支持用户自行控制生成器函数在什么位置暂停/继续执行**。所以不是每一次 yield 后面都需要跟表达式，也不是每一次 next() 都要 .value，在合适的时机进行这些操作就行了，例如：

```javascript
function* pause() {
  let a = 0;
  yield;
  a++;
  yield;
  a++;
  yield a;
}

const p = pause();
p.next();
p.next();
console.log(p.next().value);
```

## 应用

每点一次按钮，按钮的颜色就会改变，总共有四中颜色循环执行即可
