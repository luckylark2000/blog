# 性能优化

## 生产环境性能优化

### 操作

打开隐身模式，防止浏览器插件影响数据，清理内存，关闭浏览器缓存，打开 Screenshots 查看页面加载情况

进入首页，开始记录

## 分析数据

FP

DCL 7.23秒

FCP 8.13 秒

LCP 9.13 秒

分析耗时构成

脚本执行时间Scripting 385 毫秒
System 耗时 223 毫秒
渲染 Render 耗时 69 毫秒
绘制 Painting 14 毫秒

总共耗时 12.242 秒

可知大部分耗时在于网络加载
分析网络线程：

DCL 7.23 秒，之前主要是加载静态资源，需要加载不少

html 文件 4.8 KB 总耗时 568毫秒，主要耗费在等待服务器响应 552毫秒
app.contenthash.js 文件 1.2 MB 主要耗时在下载静态资源 1.77 秒
chunk.vendors.contenthash.js 第三方库 6MB 主要耗时在下载静态资源 6.17 秒

DCL 到 FCP 之间耗时 1 秒

主要耗时在
一个影响全局配置的全局接口，200ms，主要时间花在等待服务器响应，等待了160ms
home 页面静态 js 资源加载和渲染， 主要耗时在加载 3个 js 资源，三个资源并行加载，最长的耗时在 650ms（等待服务器响应250ms + 下载耗时 400ms）

FCP 到 LCP 耗时 1 秒,主要耗时在图片资源下载（主要耗费时间在等待服务器响应每个都在500ms，然后最大的一张图片下载需要差不多500ms）

### 优化方案

可以看到服务器的响应时间过长，每次发请求基本上等待服务器响应，都普遍在 160 ms-500 ms之间，最长的一些prefetch的js文件还有700+ms的，这个属于网络问题，可以使用对于首屏性能优化，可以使用

- CDN，内容分化网络，第三方的 CDN 服务一般网速比较快，而且站点分布的比较多，有限获取最近的服务器，从而提高访问速度
- 升级 http2：有服务器推送，对于需要的资源提前推送给浏览器，浏览器收到推送后，会自动下载，从而减少请求数，从而提高性能;请求头压缩；多路复用 ( http1.1最多6个连接 )。

不是首屏的话，开启缓存，需要注意对html文件开启 no-cache（每次进行协商缓存）, 然后 js 文件使用 content-hash 模式，同时开启强缓存和协商缓存（一般使用 nginx 的话，默认时开启的）

js 文件过大的时候，做的：

- 代码分割，使用 http2 的话，可以尽可能细粒度分割代码
- 懒加载
- 按需加载
- 静态资源压缩，nginx 开启 gzip
- tree shaking
- 去除冗余代码，删除注释代码

不是首屏的话，和上面一样可以开启缓存

图片优化：

- 减少图片大小：改变图片的格式（webp兼容新还可以）；压缩图片，使用特殊压缩工具来压缩图片的大小，不失真。
- 懒加载：进入视野的时候才加载，使用图片自带的 lazyload，或者 vue 指令，第三方库都可以
- 预加载：在空闲的时候提前获取（服务器推送，首屏可能用不到）
- 减少图片数量，一些图片（业界一般选小于8KB的）可以直接使用 base64，嵌入到 html中，避免发送请求
- 放 CDN
- 先加载低质量的图片，等加载完成再替换成高清图片

### 不得不说

## 开发环境性能优化

使用 source-map 的时候优先使用 cheap-module-eval-source-map

使用开发缓存